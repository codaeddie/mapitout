
# Keyboard Interaction - Simplified MapItOut

## Core Philosophy

**Keyboard-First Design**: All primary functionality accessible via keyboard
- No mouse gymnastics required
- Rapid creation and navigation
- Matches how people outline thoughts

## Primary Keyboard Shortcuts

### Node Creation
```typescript
// Tab: Create child node
case 'Tab':
  e.preventDefault();
  if (selectedId) {
    createNode(selectedId); // Creates child of selected node
  }
  break;

// Enter: Create sibling node  
case 'Enter':
  e.preventDefault();
  if (selectedId) {
    const node = nodes.get(selectedId);
    if (node?.parent) {
      createNode(node.parent); // Creates sibling of selected node
    }
  }
  break;
```

### Navigation
```typescript
// Arrow keys: Navigate between nodes
case 'ArrowUp':
case 'ArrowDown':
case 'ArrowLeft':
case 'ArrowRight':
  e.preventDefault();
  navigateToAdjacentNode(e.key);
  break;

// Escape: Clear selection
case 'Escape':
  e.preventDefault();
  selectNode(null);
  break;
```

### Text Editing
```typescript
// Enter in edit mode: New line in text
// Shift+Enter in edit mode: Complete edit
// Escape: Cancel edit
const handleEditKeyDown = (e: KeyboardEvent) => {
  if (e.key === 'Enter' && e.shiftKey) {
    e.preventDefault();
    completeEdit();
  } else if (e.key === 'Escape') {
    e.preventDefault();
    cancelEdit();
  }
};
```

## Implementation Pattern

```typescript
export function useKeyboardNavigation() {
  const store = useMapStore();
  
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Don't handle if user is editing text
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }
      
      // Don't handle if user is typing in a contenteditable
      if (e.target instanceof HTMLElement && e.target.contentEditable === 'true') {
        return;
      }
      
      switch (e.key) {
        case 'Tab':
          e.preventDefault();
          if (store.selectedId) {
            store.createNode(store.selectedId);
          }
          break;
          
        case 'Enter':
          e.preventDefault();
          if (store.selectedId) {
            const node = store.nodes.get(store.selectedId);
            if (node?.parent) {
              store.createNode(node.parent);
            }
          }
          break;
          
        case 'Escape':
          e.preventDefault();
          store.selectNode(null);
          break;
          
        case 'ArrowUp':
        case 'ArrowDown':
        case 'ArrowLeft':
        case 'ArrowRight':
          e.preventDefault();
          navigateToAdjacentNode(e.key, store);
          break;
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [store]);
}
```

## Navigation Logic

```typescript
function navigateToAdjacentNode(direction: string, store: MapStore) {
  const { nodes, selectedId } = store;
  if (!selectedId) return;
  
  const selectedNode = nodes.get(selectedId);
  if (!selectedNode) return;
  
  let targetId: string | null = null;
  
  switch (direction) {
    case 'ArrowUp':
      // Find node above in same tier
      targetId = findNodeAbove(selectedNode, nodes);
      break;
      
    case 'ArrowDown':
      // Find node below in same tier
      targetId = findNodeBelow(selectedNode, nodes);
      break;
      
    case 'ArrowLeft':
      // Find node to the left
      targetId = findNodeLeft(selectedNode, nodes);
      break;
      
    case 'ArrowRight':
      // Find node to the right
      targetId = findNodeRight(selectedNode, nodes);
      break;
  }
  
  if (targetId) {
    store.selectNode(targetId);
  }
}
```

## Text Editing States

```typescript
// Text editing state machine
type EditState = 'idle' | 'editing' | 'completing';

const [editState, setEditState] = useState<EditState>('idle');

// Single click: Select node
const handleNodeClick = (id: string) => {
  if (editState === 'idle') {
    selectNode(id);
  }
};

// Double click: Start editing
const handleNodeDoubleClick = (id: string) => {
  if (editState === 'idle') {
    setEditState('editing');
    startEditing(id);
  }
};

// Enter in edit mode: New line
// Shift+Enter in edit mode: Complete edit
const handleEditKeyDown = (e: KeyboardEvent) => {
  if (editState === 'editing') {
    if (e.key === 'Enter' && e.shiftKey) {
      e.preventDefault();
      setEditState('completing');
      completeEdit();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      setEditState('idle');
      cancelEdit();
    }
  }
};
```

## Context-Aware Behavior

```typescript
// Different behavior based on context
const handleKeyDown = (e: KeyboardEvent) => {
  // Check if user is editing
  if (isEditing) {
    handleEditKeyDown(e);
    return;
  }
  
  // Check if user is in input field
  if (e.target instanceof HTMLInputElement) {
    return; // Let browser handle
  }
  
  // Handle navigation and creation
  handleNavigationKeyDown(e);
};
```

## Accessibility Considerations

```typescript
// Provide visual feedback for keyboard navigation
const isSelected = node.id === selectedId;
const isFocused = node.id === focusedId;

return (
  <div
    className={`node ${isSelected ? 'selected' : ''} ${isFocused ? 'focused' : ''}`}
    tabIndex={0}
    role="button"
    aria-label={`Node: ${node.text}`}
    onKeyDown={handleNodeKeyDown}
  >
    {node.text}
  </div>
);
```

## Performance Optimization

```typescript
// Debounce rapid key presses
const debouncedKeyHandler = useMemo(
  () => debounce((key: string) => {
    handleKeyPress(key);
  }, 50),
  []
);

// Use callback for event handlers
const handleKeyDown = useCallback((e: KeyboardEvent) => {
  // Handler logic
}, [store, editState]);
```

## Testing Keyboard Interactions

```typescript
// Test keyboard shortcuts
describe('Keyboard Navigation', () => {
  it('should create child node on Tab', () => {
    render(<MapCanvas />);
    fireEvent.keyDown(document, { key: 'Tab' });
    expect(screen.getByText('New Node')).toBeInTheDocument();
  });
  
  it('should create sibling node on Enter', () => {
    render(<MapCanvas />);
    fireEvent.keyDown(document, { key: 'Enter' });
    expect(screen.getByText('New Node')).toBeInTheDocument();
  });
});
```
