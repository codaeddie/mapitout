
# Keyboard Interaction Patterns

## Primary Keyboard Shortcuts

| Key | Action | Context |
|-----|--------|---------|
| `Tab` | Create connected node (context-dependent) | Node selected |
| `Shift + Space` | Create unconnected node | Node selected |
| `Enter` | Start/stop text editing | Node selected |
| `Escape` | Exit edit mode | Text editing |
| `Delete` | Delete node | Node selected |
| `Arrow Keys` | Navigate connections | Node selected |
| `1-4` | Switch layout (1=Tree, 2=Web, 3=Flow, 4=Command) | Global |
| `+` / `-` | Zoom in/out | Global |
| `Space` | Pan mode toggle | Global |

## Main Keyboard Handler

```typescript
function useKeyboardNavigation() {
  const { 
    selectedId, 
    nodes, 
    connections,
    layoutType,
    createNode, 
    updateNode, 
    deleteNode, 
    selectNode,
    setLayoutType
  } = useMapStore();

  const [editingNodeId, setEditingNodeId] = useState<string | null>(null);
  
  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    // Don't handle keyboard shortcuts if user is editing text
    if (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement) {
      handleEditingKeyDown(event);
      return;
    }
    
    // Global shortcuts (always available)
    if (handleGlobalShortcuts(event)) {
      return;
    }
    
    // Node-specific shortcuts (require selected node)
    if (selectedId) {
      handleNodeShortcuts(event, selectedId);
    }
  }, [selectedId, editingNodeId]);
  
  const handleGlobalShortcuts = useCallback((event: KeyboardEvent) => {
    switch (event.key) {
      case '+':
      case '=':
        event.preventDefault();
        zoomIn();
        return true;
        
      case '-':
      case '_':
        event.preventDefault();
        zoomOut();
        return true;
        
      case ' ':
        event.preventDefault();
        togglePanMode();
        return true;
        
      default:
        return false;
    }
  }, []);
  
  const handleNodeShortcuts = useCallback((event: KeyboardEvent, nodeId: string) => {
    const { layoutType, createNode, setLayoutType } = useMapStore.getState();
    
    switch (event.key) {
      case 'Tab':
        event.preventDefault();
        // Context-aware creation based on layout type
        if (layoutType === 'hierarchical') {
          createNode('New Child', 'leaf'); // Creates hierarchy connection
        } else if (layoutType === 'web') {
          createNode('New Spoke', 'leaf'); // Creates hub-spoke connection
        } else if (layoutType === 'snake') {
          createNode('New Flow', 'leaf'); // Creates flow connection
        } else if (layoutType === 'command') {
          createNode('New Parameter', 'parameter'); // Creates parameter connection
        }
        break;
        
      case ' ':
        if (event.shiftKey) {
          event.preventDefault();
          createNode('New Node', 'leaf'); // Always creates unconnected node
        }
        break;
        
      case 'Enter':
        event.preventDefault();
        startEditing(nodeId);
        break;
        
      case 'Delete':
      case 'Backspace':
        event.preventDefault();
        deleteNode(nodeId);
        break;
        
      case '1':
        event.preventDefault();
        setLayoutType('hierarchical');
        break;
        
      case '2':
        event.preventDefault();
        setLayoutType('web');
        break;
        
      case '3':
        event.preventDefault();
        setLayoutType('snake');
        break;
        
      case '4':
        event.preventDefault();
        setLayoutType('command');
        break;
        
      case 'ArrowUp':
        event.preventDefault();
        navigateUp(nodeId);
        break;
        
      case 'ArrowDown':
        event.preventDefault();
        navigateDown(nodeId);
        break;
        
      case 'ArrowLeft':
        event.preventDefault();
        navigateLeft(nodeId);
        break;
        
      case 'ArrowRight':
        event.preventDefault();
        navigateRight(nodeId);
        break;
    }
  }, []);
  
  const handleEditingKeyDown = useCallback((event: KeyboardEvent) => {
    if (!editingNodeId) return;
    
    switch (event.key) {
      case 'Enter':
        if (!event.shiftKey) {
          event.preventDefault();
          stopEditing();
        }
        // Shift+Enter creates new line (default behavior)
        break;
        
      case 'Escape':
        event.preventDefault();
        stopEditing();
        break;
        
      case 'Tab':
        event.preventDefault();
        stopEditing();
        createNode('New Node', 'leaf');
        break;
    }
  }, [editingNodeId]);
  
  return {
    handleKeyDown,
    editingNodeId,
    setEditingNodeId,
  };
}
```

## Navigation Logic

```typescript
function useNodeNavigation() {
  const { nodes, connections, selectedId, selectNode } = useMapStore();
  
  const getConnectedNodes = useCallback((nodeId: string) => {
    return connections
      .filter(c => c.from === nodeId || c.to === nodeId)
      .map(c => c.from === nodeId ? c.to : c.from)
      .map(id => nodes.get(id))
      .filter(Boolean) as Node[];
  }, [connections, nodes]);
  
  const navigateUp = useCallback((nodeId: string) => {
    const connectedNodes = getConnectedNodes(nodeId);
    if (connectedNodes.length > 0) {
      // Select first connected node (could be improved with better logic)
      selectNode(connectedNodes[0].id);
    }
  }, [getConnectedNodes, selectNode]);
  
  const navigateDown = useCallback((nodeId: string) => {
    const connectedNodes = getConnectedNodes(nodeId);
    if (connectedNodes.length > 1) {
      // Select second connected node if available
      selectNode(connectedNodes[1].id);
    } else if (connectedNodes.length === 1) {
      selectNode(connectedNodes[0].id);
    }
  }, [getConnectedNodes, selectNode]);
  
  const navigateLeft = useCallback((nodeId: string) => {
    // Find connections where this node is the target (incoming connections)
    const incomingConnections = connections.filter(c => c.to === nodeId);
    if (incomingConnections.length > 0) {
      const sourceNode = nodes.get(incomingConnections[0].from);
      if (sourceNode) {
        selectNode(sourceNode.id);
      }
    }
  }, [connections, nodes, selectNode]);
  
  const navigateRight = useCallback((nodeId: string) => {
    // Find connections where this node is the source (outgoing connections)
    const outgoingConnections = connections.filter(c => c.from === nodeId);
    if (outgoingConnections.length > 0) {
      const targetNode = nodes.get(outgoingConnections[0].to);
      if (targetNode) {
        selectNode(targetNode.id);
      }
    }
  }, [connections, nodes, selectNode]);
  
  return {
    navigateUp,
    navigateDown,
    navigateLeft,
    navigateRight,
  };
}
```

## Node Creation Logic

```typescript
function useNodeCreation() {
  const { layoutType, createNode } = useMapStore();
  
  const createConnectedNode = useCallback((text = 'New Node') => {
    // Context-aware node creation based on layout
    const nodeType = layoutType === 'command' ? 'parameter' : 'leaf';
    createNode(text, nodeType);
  }, [layoutType, createNode]);
  
  const createUnconnectedNode = useCallback((text = 'New Node') => {
    // Always creates unconnected leaf node
    createNode(text, 'leaf');
  }, [createNode]);
  
  return {
    createConnectedNode,
    createUnconnectedNode,
  };
}
```

## Text Editing Logic

```typescript
function useTextEditing() {
  const { nodes, updateNode } = useMapStore();
  const [editingNodeId, setEditingNodeId] = useState<string | null>(null);
  const [editingText, setEditingText] = useState('');
  
  const startEditing = useCallback((nodeId: string) => {
    const node = nodes.get(nodeId);
    if (!node) return;
    
    setEditingNodeId(nodeId);
    setEditingText(node.text);
    
    // Focus the input after a brief delay
    setTimeout(() => {
      const input = document.querySelector(`[data-node-id="${nodeId}"] input`);
      if (input instanceof HTMLInputElement) {
        input.focus();
        input.select();
      }
    }, 0);
  }, [nodes]);
  
  const stopEditing = useCallback(() => {
    if (!editingNodeId) return;
    
    // Save the text if it's changed
    const node = nodes.get(editingNodeId);
    if (node && editingText !== node.text) {
      updateNode(editingNodeId, { text: editingText });
    }
    
    setEditingNodeId(null);
    setEditingText('');
  }, [editingNodeId, editingText, nodes, updateNode]);
  
  const handleTextChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    setEditingText(event.target.value);
  }, []);
  
  return {
    editingNodeId,
    editingText,
    startEditing,
    stopEditing,
    handleTextChange,
  };
}
```

## Event Listener Setup

```typescript
function useGlobalKeyboardListeners() {
  const { handleKeyDown } = useKeyboardNavigation();
  
  useEffect(() => {
    // Add global keyboard listener
    document.addEventListener('keydown', handleKeyDown);
    
    // Cleanup
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown]);
}
```

## Focus Management

```typescript
function useFocusManagement() {
  const { selectedId } = useMapStore();
  
  useEffect(() => {
    if (selectedId) {
      // Ensure selected node is visible and focused
      const nodeElement = document.querySelector(`[data-node-id="${selectedId}"]`);
      if (nodeElement) {
        nodeElement.scrollIntoView({ 
          behavior: 'smooth', 
          block: 'nearest' 
        });
        
        // Set focus for keyboard navigation
        if (nodeElement instanceof HTMLElement) {
          nodeElement.focus();
        }
      }
    }
  }, [selectedId]);
}
```

## Accessibility Support

```typescript
function NodeComponent({ node, isSelected, connections }: NodeComponentProps) {
  const connectedCount = connections.filter(c => c.from === node.id || c.to === node.id).length;
  
  return (
    <div
      data-node-id={node.id}
      role="treeitem"
      aria-selected={isSelected}
      aria-expanded={connectedCount > 0}
      aria-level={node.layoutHints.layer || 1}
      tabIndex={isSelected ? 0 : -1}
      className={`node ${isSelected ? 'selected' : ''}`}
    >
      {node.text}
      
      {/* Keyboard hints for selected node */}
      {isSelected && (
        <div className="sr-only">
          Press Tab to create connected node, Shift+Space for unconnected, Enter to edit, 1-4 to switch layouts
        </div>
      )}
    </div>
  );
}
```

    </div>
  );
}

```
