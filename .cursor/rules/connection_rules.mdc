
# Connection-Based Relationship System

## Core Connection Model

```typescript
interface Connection {
  id: string;                    // Unique identifier
  from: string;                  // Source node ID
  to: string;                    // Target node ID
  type: 'hierarchy' | 'association' | 'flow' | 'parameter';
  style: 'straight' | 'curved';  // Visual style
}
```

## Connection Types and Semantics

### Hierarchy Connections

```typescript
type: 'hierarchy'
style: 'curved'
```

- **Use case**: Traditional parent-child relationships
- **Layout behavior**: Tree structures, tier-based positioning
- **Visual style**: Curved lines, hierarchical appearance
- **Creation**: Tab key in hierarchical layout mode

### Association Connections  

```typescript
type: 'association'
style: 'straight'
```

- **Use case**: Peer relationships, web structures
- **Layout behavior**: Hub-spoke, force-directed
- **Visual style**: Straight lines, equal relationships
- **Creation**: Tab key in web layout mode

### Flow Connections

```typescript
type: 'flow'
style: 'curved'
```

- **Use case**: Process flows, sequential relationships
- **Layout behavior**: Directional flow, snake-like
- **Visual style**: Curved lines with flow direction
- **Creation**: Tab key in snake layout mode

### Parameter Connections

```typescript
type: 'parameter'
style: 'straight'
```

- **Use case**: Command parameters, configuration options
- **Layout behavior**: Radial grouping by category
- **Visual style**: Straight lines, grouped appearance
- **Creation**: Tab key in command layout mode

## Connection Management Actions

### Create Connection

```typescript
createConnection: (from: string, to: string, type = 'association') => {
  set(state => {
    const newConnection: Connection = {
      id: nanoid(),
      from,
      to,
      type: type as any,
      style: type === 'hierarchy' || type === 'flow' ? 'curved' : 'straight',
    };
    
    return {
      connections: [...state.connections, newConnection]
    };
  });
}
```

### Delete Connection

```typescript
deleteConnection: (connectionId: string) => {
  set(state => ({
    connections: state.connections.filter(c => c.id !== connectionId)
  }));
}
```

### Auto-Connect on Node Creation

```typescript
createNode: (text = 'New Node', nodeType = 'leaf') => {
  const { nodes, connections, selectedId, layoutType } = get();
  
  const newNode: Node = {
    id: nanoid(),
    text,
    x: 400,
    y: 300,
    nodeType: nodeType as any,
    category: 0,
    isEditing: true,
    layoutHints: {},
  };
  
  set(state => {
    const newNodes = new Map(state.nodes);
    newNodes.set(newNode.id, newNode);
    
    let newConnections = [...state.connections];
    
    // Auto-connect based on layout type and selection
    if (selectedId) {
      const connectionType = getConnectionTypeForLayout(layoutType);
      newConnections.push({
        id: nanoid(),
        from: selectedId,
        to: newNode.id,
        type: connectionType,
        style: connectionType === 'hierarchy' || connectionType === 'flow' ? 'curved' : 'straight',
      });
    }
    
    // Recalculate layout
    const engine = layoutEngines[state.layoutType];
    engine.calculatePositions(newNodes, newConnections);
    
    return {
      nodes: newNodes,
      connections: newConnections,
      selectedId: newNode.id,
    };
  });
}
```

## Connection Type Selection Logic

```typescript
function getConnectionTypeForLayout(layoutType: string): Connection['type'] {
  switch (layoutType) {
    case 'hierarchical': return 'hierarchy';
    case 'web': return 'association';
    case 'snake': return 'flow';
    case 'command': return 'parameter';
    default: return 'association';
  }
}
```

## Connection Rendering System

### Canvas Layer Implementation

```typescript
interface ConnectionLayerProps {
  connections: Connection[];
  nodes: Map<string, Node>;
  selectedConnectionId?: string | null;
}

export function ConnectionLayer({ connections, nodes, selectedConnectionId }: ConnectionLayerProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Render each connection
    connections.forEach(connection => {
      renderConnection(ctx, connection, nodes, selectedConnectionId === connection.id);
    });
  }, [connections, nodes, selectedConnectionId]);
  
  return (
    <canvas
      ref={canvasRef}
      className="absolute inset-0 pointer-events-none"
      width={1600}
      height={1200}
    />
  );
}
```

### Connection Rendering Functions

```typescript
function renderConnection(
  ctx: CanvasRenderingContext2D,
  connection: Connection,
  nodes: Map<string, Node>,
  isSelected: boolean
): void {
  const fromNode = nodes.get(connection.from);
  const toNode = nodes.get(connection.to);
  
  if (!fromNode || !toNode) return;
  
  // Set visual style based on connection type
  const style = getConnectionStyle(connection, isSelected);
  applyConnectionStyle(ctx, style);
  
  // Draw connection based on style
  if (connection.style === 'curved') {
    drawCurvedConnection(ctx, fromNode, toNode);
  } else {
    drawStraightConnection(ctx, fromNode, toNode);
  }
  
  // Add arrowhead for flow connections
  if (connection.type === 'flow') {
    drawArrowhead(ctx, fromNode, toNode);
  }
}

function getConnectionStyle(connection: Connection, isSelected: boolean) {
  const baseStyle = {
    hierarchy: { color: '#64748b', width: 2 },
    association: { color: '#f97316', width: 2 },
    flow: { color: '#3b82f6', width: 3 },
    parameter: { color: '#10b981', width: 1 },
  }[connection.type];
  
  return {
    ...baseStyle,
    width: isSelected ? baseStyle.width + 1 : baseStyle.width,
    opacity: isSelected ? 1 : 0.8,
  };
}

function applyConnectionStyle(ctx: CanvasRenderingContext2D, style: any): void {
  ctx.strokeStyle = style.color;
  ctx.lineWidth = style.width;
  ctx.globalAlpha = style.opacity;
}

function drawStraightConnection(ctx: CanvasRenderingContext2D, from: Node, to: Node): void {
  ctx.beginPath();
  ctx.moveTo(from.x, from.y);
  ctx.lineTo(to.x, to.y);
  ctx.stroke();
}

function drawCurvedConnection(ctx: CanvasRenderingContext2D, from: Node, to: Node): void {
  const midX = (from.x + to.x) / 2;
  const midY = (from.y + to.y) / 2;
  
  // Calculate control point for curve
  const distance = Math.sqrt((to.x - from.x) ** 2 + (to.y - from.y) ** 2);
  const offset = Math.min(distance * 0.3, 100);
  
  const cpX = midX + (to.y - from.y) * offset / distance;
  const cpY = midY - (to.x - from.x) * offset / distance;
  
  ctx.beginPath();
  ctx.moveTo(from.x, from.y);
  ctx.quadraticCurveTo(cpX, cpY, to.x, to.y);
  ctx.stroke();
}

function drawArrowhead(ctx: CanvasRenderingContext2D, from: Node, to: Node): void {
  const angle = Math.atan2(to.y - from.y, to.x - from.x);
  const arrowLength = 15;
  const arrowAngle = 0.5;
  
  const x1 = to.x - arrowLength * Math.cos(angle - arrowAngle);
  const y1 = to.y - arrowLength * Math.sin(angle - arrowAngle);
  const x2 = to.x - arrowLength * Math.cos(angle + arrowAngle);
  const y2 = to.y - arrowLength * Math.sin(angle + arrowAngle);
  
  ctx.beginPath();
  ctx.moveTo(to.x, to.y);
  ctx.lineTo(x1, y1);
  ctx.moveTo(to.x, to.y);
  ctx.lineTo(x2, y2);
  ctx.stroke();
}
```

## Connection Hit Testing

```typescript
function useConnectionHitTesting(connections: Connection[], nodes: Map<string, Node>) {
  const handleCanvasClick = useCallback((event: MouseEvent) => {
    const rect = (event.target as HTMLCanvasElement).getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const clickY = event.clientY - rect.top;
    
    // Find clicked connection
    const clickedConnection = findConnectionAt(clickX, clickY, connections, nodes);
    
    if (clickedConnection) {
      // Handle connection selection/deletion
      onConnectionClick(clickedConnection.id);
    }
  }, [connections, nodes]);
  
  return { handleCanvasClick };
}

function findConnectionAt(
  x: number, 
  y: number, 
  connections: Connection[], 
  nodes: Map<string, Node>
): Connection | null {
  for (const connection of connections) {
    const fromNode = nodes.get(connection.from);
    const toNode = nodes.get(connection.to);
    
    if (!fromNode || !toNode) continue;
    
    const distance = distanceToLine(x, y, fromNode.x, fromNode.y, toNode.x, toNode.y);
    
    if (distance < 10) { // 10px tolerance
      return connection;
    }
  }
  
  return null;
}

function distanceToLine(x: number, y: number, x1: number, y1: number, x2: number, y2: number): number {
  const A = x - x1;
  const B = y - y1;
  const C = x2 - x1;
  const D = y2 - y1;
  
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  
  if (lenSq !== 0) {
    param = dot / lenSq;
  }
  
  let xx, yy;
  
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }
  
  const dx = x - xx;
  const dy = y - yy;
  
  return Math.sqrt(dx * dx + dy * dy);
}
```

## Connection Validation

```typescript
function validateConnection(from: string, to: string, nodes: Map<string, Node>): boolean {
  // Don't allow self-connections
  if (from === to) return false;
  
  // Check nodes exist
  if (!nodes.has(from) || !nodes.has(to)) return false;
  
  // Don't allow duplicate connections (check in store before creating)
  return true;
}

function hasDuplicateConnection(from: string, to: string, connections: Connection[]): boolean {
  return connections.some(c => 
    (c.from === from && c.to === to) || 
    (c.from === to && c.to === from) // Treat as bidirectional
  );
}
```

## Keyboard Shortcuts for Connections

```typescript
// In keyboard navigation hook
case 'x':
  if (event.ctrlKey && selectedConnectionId) {
    event.preventDefault();
    deleteConnection(selectedConnectionId);
  }
  break;
  
case 'c':
  if (event.ctrlKey && selectedId && secondarySelectedId) {
    event.preventDefault();
    createConnection(selectedId, secondarySelectedId);
  }
  break;
```

## Connection State Persistence

```typescript
// In zustand persist configuration
partialize: (state) => ({
  nodes: Array.from(state.nodes.entries()),
  connections: state.connections, // Persist connections explicitly
  rootId: state.rootId,
  layoutType: state.layoutType,
  viewBox: state.viewBox,
  zoomLevel: state.zoomLevel,
})
```

## Layout Engine Integration

Each layout engine operates on explicit connections:

```typescript
// Layout engines receive connections and use them for positioning
calculatePositions(nodes: Map<string, Node>, connections: Connection[]): void {
  const relevantConnections = connections.filter(c => 
    this.isRelevantConnectionType(c.type)
  );
  
  // Use connections to determine positioning logic
  this.positionBasedOnConnections(nodes, relevantConnections);
}
```

## Performance Optimization

1. **Connection Culling**: Only render visible connections
2. **Batch Updates**: Group connection changes
3. **Efficient Hit Testing**: Use spatial indexing for large connection counts
4. **Canvas Optimization**: Minimize redraw operations

## Testing Strategy

1. **Connection Creation**: Verify auto-connection works per layout
2. **Connection Deletion**: Verify cleanup of orphaned nodes
3. **Connection Rendering**: Verify visual styles per type
4. **Layout Integration**: Verify connections affect positioning
5. **Hit Testing**: Verify connection selection works
6. **Persistence**: Verify connections survive reload

## Migration from Hierarchy

To migrate existing parent-child relationships:

```typescript
function migrateHierarchyToConnections(nodes: Map<string, Node>): Connection[] {
  const connections: Connection[] = [];
  
  for (const node of nodes.values()) {
    if (node.parentId) {
      connections.push({
        id: nanoid(),
        from: node.parentId,
        to: node.id,
        type: 'hierarchy',
        style: 'curved',
      });
    }
  }
  
  return connections;
}
```

The connection system provides the foundation for multi-layout flexibility while maintaining explicit, queryable relationships between nodes.

}

```

The connection system provides the foundation for multi-layout flexibility while maintaining explicit, queryable relationships between nodes.
