---
# NOTE: This rule covers persistence and localStorage. For store structure and actions, see [state-management.mdc](mdc:state-management.mdc).

## Zustand Persist Configuration

MapItOut uses Zustand's persist middleware for localStorage state management with environment-specific behavior.

### Core Persist Setup

```typescript
// src/stores/map-store.ts
const useMapStore = create<MapState>()(
  persist(
    (set, get) => ({
      // Store implementation
    }),
    {
      name: 'mapitout-store',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        nodes: Array.from(state.nodes.entries()),
        rootId: state.rootId,
        viewBox: state.viewBox,
        zoomLevel: state.zoomLevel,
      }),
      merge: (persisted, current) => {
        // Environment-specific merge logic
      },
    }
  )
);
```

### State Serialization (partialize)

**What gets saved to localStorage:**
```typescript
partialize: (state) => ({
  nodes: Array.from(state.nodes.entries()), // Convert Map to array
  rootId: state.rootId,                     // Root node ID
  viewBox: state.viewBox,                   // Canvas viewport
  zoomLevel: state.zoomLevel,               // Current zoom level
  // Note: connections are recalculated, not persisted
  // Note: selectedId is not persisted (UI state)
})
```

### State Deserialization (merge)

**Environment-Specific Merge Logic:**
```typescript
merge: (persisted, current) => {
  // Development: ignore persisted state
  if (isDevelopment) {
    console.log('Development mode: ignoring persisted state');
    return current;
  }
  
  // Production: merge with corruption check
  const { nodes = [], rootId = '', viewBox = { x: 0, y: 0, width: 1600, height: 1200 }, zoomLevel = 1 } = persisted as any;
  
  // Corruption detection
  if (nodes && Array.isArray(nodes)) {
    const hasCorruptedCoords = nodes.some(([_, node]: [string, any]) => 
      node.x < -1000 || node.x > 2000 || node.y < -1000 || node.y > 2000
    );
    if (hasCorruptedCoords) {
      console.log('Production: clearing corrupted localStorage state');
      return current;
    }
  }
  
  return {
    ...current,
    nodes: new Map(nodes), // Convert array back to Map
    rootId,
    viewBox,
    zoomLevel,
  };
}
```

## State Structure

### Persisted State
```typescript
interface PersistedState {
  nodes: [string, Node][];           // Array of [id, node] pairs
  rootId: string;                    // Root node identifier
  viewBox: ViewBox;                  // Canvas viewport
  zoomLevel: number;                 // Zoom level
}
```

### Non-Persisted State
```typescript
interface NonPersistedState {
  selectedId: string | null;         // UI state - not persisted
  connections: Connection[];         // Calculated from nodes
  isEditing: boolean;               // UI state - not persisted
}
```

## Corruption Detection

### Coordinate Validation
```typescript
const hasCorruptedCoords = nodes.some(([_, node]: [string, any]) => 
  node.x < -1000 || node.x > 2000 || node.y < -1000 || node.y > 2000
);
```

### Recovery Strategies
1. **Return fresh state** (current implementation)
2. **Attempt repair** (future enhancement)
3. **User notification** (future enhancement)

## Development Mode Features

### Manual Reset Function
```typescript
resetForDevelopment: () => {
  if (isDevelopment) {
    console.log('Development mode: resetting state to fresh');
    set({
      nodes: new Map(),
      rootId: '',
      selectedId: null,
      viewBox: { x: 0, y: 0, width: 1600, height: 1200 },
      zoomLevel: 1,
      connections: [],
    });
  }
}
```

### Auto-Reset on Mount
```typescript
// App.tsx
useEffect(() => {
  if (import.meta.env.DEV) {
    resetForDevelopment();
  }
}, [resetForDevelopment]);
```

## Production Mode Features

### Full Persistence
- All user work is preserved
- State survives browser restarts
- Corruption detection and recovery

### Performance Optimizations
- Only essential data persisted
- Connections recalculated on load
- UI state not persisted

## Storage Management

### localStorage Key
```typescript
name: 'mapitout-store'  // localStorage key
```

### Storage Fallback
```typescript
storage: createJSONStorage(() => {
  try {
    return window.localStorage;
  } catch (e) {
    console.error('Failed to access localStorage:', e);
    // Fallback to in-memory storage
    return {
      getItem: () => null,
      setItem: () => {},
      removeItem: () => {},
    };
  }
})
```

## Best Practices

### State Design
1. **Separate persistent from transient state**
2. **Use partialize to control what's saved**
3. **Implement corruption detection**
4. **Provide recovery mechanisms**

### Performance
1. **Only persist essential data**
2. **Recalculate derived state on load**
3. **Use efficient serialization**
4. **Implement proper cleanup**

### Development
1. **Provide reset mechanisms**
2. **Add debugging tools**
3. **Log state changes**
4. **Test both environments**

## Debugging State Issues

### Check Current State
```typescript
// Browser console
console.log('Current state:', useMapStore.getState());
```

### Check localStorage
```typescript
// Browser console
console.log('localStorage:', localStorage.getItem('mapitout-store'));
```

### Force Reset
```typescript
// Browser console
useMapStore.getState().resetForDevelopment();
```

### Clear Storage
```typescript
// Browser console
localStorage.removeItem('mapitout-store');
location.reload();
```
description:
globs:
alwaysApply: false
---
