
# Zustand State Management for MapItOut

## Core Store Structure

```typescript
interface MapState {
  // Core Data
  nodes: Map<string, Node>;
  connections: Connection[];
  rootId: string;
  selectedId: string | null;
  
  // Layout State
  layoutType: 'hierarchical' | 'web' | 'snake' | 'command';
  
  // View State
  viewBox: { x: number; y: number; width: number; height: number };
  zoomLevel: number;
  
  // Actions
  createNode: (text?: string, nodeType?: string) => void;
  createConnection: (from: string, to: string, type?: string) => void;
  deleteNode: (id: string) => void;
  deleteConnection: (id: string) => void;
  setLayoutType: (type: string) => void;
  updateNode: (id: string, updates: Partial<Node>) => void;
  selectNode: (id: string) => void;
  
  // Layout Actions
  recalculateLayout: () => void;
  commitNodePosition: (id: string, x: number, y: number) => void;
}
```

## Store Implementation Pattern

```typescript
import { create } from 'zustand';
import { nanoid } from 'nanoid';
import { layoutEngines } from '../utils/layout-engines';

// Helper function for connection type selection
function getConnectionTypeForLayout(layoutType: string): Connection['type'] {
  switch (layoutType) {
    case 'hierarchical': return 'hierarchy';
    case 'web': return 'association';
    case 'snake': return 'flow';
    case 'command': return 'parameter';
    default: return 'association';
  }
}

const useMapStore = create<MapState>((set, get) => ({
  // Initial State
  nodes: new Map(),
  connections: [],
  rootId: '',
  selectedId: null,
  layoutType: 'hierarchical',
  viewBox: { x: 0, y: 0, width: 1600, height: 1200 },
  zoomLevel: 1,
  
  // Node Management Actions
  createNode: (text = 'New Node', nodeType = 'leaf') => {
    const { nodes, connections, selectedId, layoutType } = get();
    
    const newNode: Node = {
      id: nanoid(),
      text,
      x: 400,
      y: 300,
      nodeType: nodeType as any,
      category: 0,
      isEditing: true,
      layoutHints: {},
    };
    
    set(state => {
      const newNodes = new Map(state.nodes);
      newNodes.set(newNode.id, newNode);
      
      let newConnections = [...state.connections];
      
      // Auto-connect based on layout type and selection
      if (selectedId) {
        const connectionType = getConnectionTypeForLayout(layoutType);
        newConnections.push({
          id: nanoid(),
          from: selectedId,
          to: newNode.id,
          type: connectionType,
          style: connectionType === 'hierarchy' || connectionType === 'flow' ? 'curved' : 'straight',
        });
      }
      
      // Recalculate layout
      const engine = layoutEngines[state.layoutType];
      if (engine) {
        engine.calculatePositions(newNodes, newConnections);
      }
      
      return {
        nodes: newNodes,
        connections: newConnections,
        selectedId: newNode.id,
      };
    });
  },
  
  createConnection: (from: string, to: string, type = 'association') => {
    set(state => ({
      connections: [...state.connections, {
        id: nanoid(),
        from,
        to,
        type: type as any,
        style: type === 'hierarchy' || type === 'flow' ? 'curved' : 'straight',
      }]
    }));
  },
  
  updateNode: (id: string, updates: Partial<Node>) => {
    set(state => {
      const newNodes = new Map(state.nodes);
      const node = newNodes.get(id);
      
      if (!node) return state;
      
      newNodes.set(id, { ...node, ...updates });
      
      return { nodes: newNodes };
    });
  },
  
  deleteNode: (id: string) => {
    set(state => {
      const newNodes = new Map(state.nodes);
      newNodes.delete(id);
      
      const newConnections = state.connections.filter(c => 
        c.from !== id && c.to !== id
      );
      
      return {
        nodes: newNodes,
        connections: newConnections,
        selectedId: state.selectedId === id ? null : state.selectedId,
      };
    });
  },
  
  deleteConnection: (connectionId: string) => {
    set(state => ({
      connections: state.connections.filter(c => c.id !== connectionId)
    }));
  },
  
  selectNode: (id: string) => {
    set({ selectedId: id });
  },
  
  setLayoutType: (type: string) => {
    set(state => {
      const engine = layoutEngines[type as keyof typeof layoutEngines];
      if (engine) {
        engine.calculatePositions(state.nodes, state.connections);
      }
      
      return { layoutType: type as any };
    });
  },
  
  // Layout Actions
  commitNodePosition: (id: string, x: number, y: number) => {
    set(state => {
      const newNodes = new Map(state.nodes);
      const node = newNodes.get(id);
      
      if (!node) return state;
      
      newNodes.set(id, { 
        ...node, 
        x, 
        y,
        layoutHints: {
          ...node.layoutHints,
          manualPosition: true,
        }
      });
      
      return { nodes: newNodes };
    });
  },
  
  recalculateLayout: () => {
    const { nodes, connections, layoutType } = get();
    
    const engine = layoutEngines[layoutType];
    if (engine) {
      const newNodes = new Map(nodes);
      engine.calculatePositions(newNodes, connections);
      set({ nodes: newNodes });
    }
  },
  
  // Export Actions
  exportToPNG: async () => {
    // Implementation would go here
    console.log('Exporting to PNG...');
  },
}));
```

## Selector Patterns

**Efficient Selectors:**

```typescript
// Good: Specific selectors prevent unnecessary re-renders
const selectedNode = useMapStore(state => 
  state.selectedId ? state.nodes.get(state.selectedId) : null
);

const nodeConnections = useMapStore(state => 
  state.connections.filter(c => 
    c.from === nodeId || c.to === nodeId
  )
);

// Bad: Will re-render on any state change
const entireState = useMapStore(state => state);
```

**Computed Values:**

```typescript
const useNodeStats = () => {
  return useMapStore(state => ({
    totalNodes: state.nodes.size,
    totalConnections: state.connections.length,
    selectedNodeConnections: state.selectedId ? 
      state.connections.filter(c => c.from === state.selectedId || c.to === state.selectedId).length : 0,
  }));
};
```

## Action Patterns

**Batch Updates:**

```typescript
// Good: Single state update
const createMultipleNodes = (nodeTexts: string[]) => {
  const { nodes, connections, selectedId, layoutType } = get();
  
  set(state => {
    const newNodes = new Map(state.nodes);
    const newConnections = [...state.connections];
    const newNodeIds: string[] = [];
    
    nodeTexts.forEach(text => {
      const newNode: Node = {
        id: nanoid(),
        text,
        x: 400,
        y: 300,
        nodeType: 'leaf',
        category: 0,
        isEditing: false,
        layoutHints: {},
      };
      
      newNodes.set(newNode.id, newNode);
      newNodeIds.push(newNode.id);
      
      // Connect to selected node if available
      if (selectedId) {
        const connectionType = getConnectionTypeForLayout(layoutType);
        newConnections.push({
          id: nanoid(),
          from: selectedId,
          to: newNode.id,
          type: connectionType,
          style: connectionType === 'hierarchy' || connectionType === 'flow' ? 'curved' : 'straight',
        });
      }
    });
    
    // Recalculate layout once
    const engine = layoutEngines[state.layoutType];
    if (engine) {
      engine.calculatePositions(newNodes, newConnections);
    }
    
    return {
      nodes: newNodes,
      connections: newConnections,
    };
  });
};
```

## Persistence Patterns

**Auto-Save to localStorage:**

```typescript
const useMapStore = create<MapState>()(
  persist(
    (set, get) => ({
      // ... store implementation
    }),
    {
      name: 'mapitout-storage',
      storage: createJSONStorage(() => localStorage),
      // Only persist essential data
      partialize: (state) => ({
        nodes: Array.from(state.nodes.entries()),
        connections: state.connections,
        rootId: state.rootId,
        layoutType: state.layoutType,
        viewBox: state.viewBox,
        zoomLevel: state.zoomLevel,
      }),
    }
  )
);
```

## Store Organization

**Split Complex State:**

```typescript
// Separate UI state from data state
const useUIStore = create<UIState>((set) => ({
  sidebarOpen: false,
  showGrid: true,
  theme: 'dark',
  
  toggleSidebar: () => set(state => ({ sidebarOpen: !state.sidebarOpen })),
  toggleGrid: () => set(state => ({ showGrid: !state.showGrid })),
}));

// Keep map data separate
const useMapStore = create<MapState>((set, get) => ({
  // ... map-specific state
}));
```

## Testing Patterns

**Store Testing:**

```typescript
// Test store actions
describe('MapStore', () => {
  beforeEach(() => {
    useMapStore.setState({
      nodes: new Map(),
      connections: [],
      rootId: '',
      selectedId: null,
      layoutType: 'hierarchical',
    });
  });
  
  test('creates new node', () => {
    const { createNode } = useMapStore.getState();
    
    createNode('Test Node', 'leaf');
    
    const { nodes } = useMapStore.getState();
    expect(nodes.size).toBe(1);
  });
  
  test('creates connection between nodes', () => {
    const { createNode, createConnection } = useMapStore.getState();
    
    createNode('Node 1', 'leaf');
    createNode('Node 2', 'leaf');
    
    const { nodes, connections } = useMapStore.getState();
    const nodeIds = Array.from(nodes.keys());
    
    createConnection(nodeIds[0], nodeIds[1], 'association');
    
    const { connections: newConnections } = useMapStore.getState();
    expect(newConnections.length).toBe(1);
  });
});
```

```
    expect(nodes.size).toBe(1);
  });
});

```
